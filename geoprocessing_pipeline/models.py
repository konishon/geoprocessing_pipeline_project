from pydantic import BaseModel, Field, model_validator
from typing import List, Dict, Any, Union, Optional
import os

class OsmDataInput(BaseModel):
    address: str = Field(..., description="Geographical location (e.g., 'Kathmandu, Nepal') for extracting OpenStreetMap data.")
    filepath: str = Field(..., description="Filepath for storing or retrieving pre-downloaded OSM data in GraphML format.")

    # Always keep this validator to automatically set the filepath based on address
    @model_validator(mode='before')
    def set_filepath(cls, values):
        if isinstance(values, dict):  # Ensure 'values' is a dictionary
            address = values.get('address')
            if address and not values.get('filepath'):
                # Use the address as the filename, replace spaces with underscores and save in data/ folder
                filename = f"{address.replace(' ', '_').lower()}.graphml"
                values['filepath'] = os.path.join('data', filename)
        return values

class IsochroneParameters(BaseModel):
    distance: int = Field(..., description="Buffer distance from the central point in meters to calculate the isochrone.")
    time: int = Field(..., description="Travel time in minutes to compute the isochrone for a time-based analysis.")

class FilterCriteria(BaseModel):
    attribute: str = Field(..., description="Geospatial attribute or field (e.g., 'height', 'population') used to filter data.")
    operator: str = Field(..., description="Logical operator for comparison (e.g., '>', '<', '=', '!=') to apply to the specified attribute.")
    value: Union[int, float] = Field(..., description="Threshold or value for the attribute filter (e.g., height > 20).")

class LoadDataInput(BaseModel):
    dataType: str = Field(..., description="The type of geospatial dataset to be loaded (e.g., 'points', 'polygons', 'roads').")

class FunctionInput(BaseModel):
    data: Union[str, OsmDataInput, Dict[str, Any]] = Field(..., description="Input dataset or reference ID for the current function.")
    parameters: Union[IsochroneParameters, FilterCriteria, LoadDataInput] = Field(..., description="Additional parameters needed for the function.")

class FunctionStep(BaseModel):
    functionName: str = Field(..., description="The GIS function or operation to be executed (e.g., 'loadOsmData', 'generateIsochrone', 'filterPoints').")
    input: FunctionInput = Field(..., description="Input data and parameters required to perform the function.")
    output: str = Field(..., description="Identifier for storing the output generated by the function for subsequent operations.")

class GeoprocessingPipeline(BaseModel):
    functions: Optional[List[FunctionStep]] = Field(None, description="Optional sequential list of geospatial functions and operations that define the processing pipeline.")
